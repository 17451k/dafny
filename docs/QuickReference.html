<!DOCTYPE html>
<html lang="en-US" class="no-js">
<body>
<h1>Dafny Quick Reference</h1>
<p>This page illustrates many of the most common language features in Dafny.  In order to get you started more quickly, the descriptions here are simplified&#8211;this page is not the language reference.  For example, this pages does not go into modules, iterators, or refinement, which you won&#8217;t need until you write larger or more advanced programs in Dafny.</p>
<h2>Programs</h2>
<p>At the top level, a Dafny program (stored as a file with extension .dfy) is a set of declarations. The declarations introduce <em>types</em>, <em>methods,</em> and <em>functions</em>, where the order of introduction is irrelevant.  These user-defined types include <em>classes</em> and <em>inductive datatypes</em>.  The classes themselves also contain a set of declarations, introducing <em>fields</em>, methods, and functions.  If the program contains a parameter-less method called Main, then execution of the compiled program starts there, but it is not necessary to have a main method to do verification.</p>
<p>Comments start with // and go to the end of the line, or start with /* and end with */ and can be nested.</p>
<h2>Fields</h2>
<p>In a class, a field x of some type T is declared as:</p>
<p>var x: T</p>
<p>Unlike for local variables and bound variables, the type is required and will not be inferred. The field can be declared to be a ghost field by preceding the declaration with the keyword ghost. Dafny's types include bool for booleans, int for mathematical (that is, unbounded) integers, string for strings, user-defined classes and inductive datatypes, set<t> for a finite mathematical (immutable) set of T values (where T is a type), and seq</t><t> for a mathematical (immutable) sequence of T values. In addition, there are array types (which are like predefined "class" types) of one and more dimensions, written array</t><t>, array2</t><t>, array3</t><t>, etc. The type object is a supertype of all class types, that is, an object denotes any reference, including null. Another useful type is nat, which denotes a subrange of int, namely the non-negative integers.</t></p>
<h2>Methods</h2>
<p>A method declaration (either at the top level or inside a class) has the form:</p>
<pre>
method M(a: A, b: B, c: C) returns (x: X, y: Y, z: Y)
  requires Pre 
  modifies Frame 
  ensures Post 
  decreases Rank
{
  Body
}
</pre>
</p>
<p>where a, b, c are the method's in-parameters, x, y, z are the method's out-parameters, Pre is a boolean expression denoting the method's precondition, Frame denotes a set of objects whose fields may be updated by the method, Post is a boolean expression denoting the method's postcondition, Rank is the method's variant function, and Body is a statement that implements the method. Frame can be a list of expressions, each of which is a set of objects or a single object, the latter standing for the singleton set consisting of that one object. The method's frame is the union of these sets, plus the set of objects allocated by the method body.  For example, if c and d are parameters of a class type C, then</p>
<pre>
  modifies {c, d}
  modifies {c} + {d}
  modifies c, {d}
  modifies c, d
</pre>
<p>all mean the same thing.</p>
<p>If omitted, the pre- and postconditions default to true and the frame defaults to the empty set. The variant function is a list of expressions, denoting the unending lexicographic tuple consisting of the given expressions followed implicitly by “top” elements. If omitted, Dafny will guess a variant function for the method, namely the lexicographic tuple that starts with the list of the method's in-parameters.</p>
<p>A method can be declared as ghost by preceding the declaration with the keyword ghost. By default, a method in a class has an implicit receiver parameter, this. This parameter can be removed by preceding the method declaration with the keyword static. A static method M in a class C can be invoked by C.M(...).</p>
<p>In a class, a method can be declared to be a constructor method by replacing the keyword method with the keyword constructor. A constructor can only be called at the time an object is allocated (see object-creation examples below), and for a class that contains one or more constructors, object creation must be done in conjunction with a call to a constructor.  Ordinarily, a method has a name, of course, but a class is allowed to have one constructor without a name&#8211;an <em>anonymous constructor</em>&#8211;like this:</p>
<pre>
  constructor (n: int)
    modifies this 
  {
    Body
  }
</pre>
<p>Often, ghost methods are used as lemmas.  This can be made clearer in the program text by declaring the method with lemma instead of ghost method.</p>
<p>Here is an example method that takes 3 integers as in-parameters and returns these in 3 out-parameters in sorted order:</p>
<pre>
method Sort(a: int b: int, c: int) returns (x: int, y: int, z: int)
  ensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z}
{
  x, y, z := a, b, c;
  if z < y {
    y, z := z, y;
  }
  if y < x {
    x, y := y, x;
  }
  if z < y {
    y, z := z, y;
  }
}
</pre>
<h2>Functions</h2>
<p>A function declaration (either at the top level or inside a class) has the form:</p>
<pre>
function F(a: A, b: B, c: C): T
  requires Pre
  reads Frame
  ensures Post
  decreases Rank
{
  Body
}
</pre>
<p>where a, b, c are the method's parameters, T is the type of the function's result, 
Pre is a boolean expression denoting the function's precondition, 
Frame denotes a set of objects whose fields the function body may depend on, 
Post is a boolean expression denoting the function's postcondition, 
Rank is the function's variant function, 
and Body is an expression that defines the function.  
The precondition allows a function to be partial, that is, the precondition says when the function is defined (and Dafny will verify that every use of the function meets the precondition). The postcondition is usually not needed, since the body of the function gives the full definition. However, the postcondition can be a convenient place to declare properties of the function that may require an inductive proof to establish. For example:</p>
<pre>
function Factorial(n: int): int
  requires 0 <= n
ensures 1 <= Factorial(n)
{
if n == 0 then 1 else Factorial(n-1) * n
}
</pre>
<p>says that the result of Factorial is always positive, which Dafny verifies inductively from the function body. To refer to the function's result in the postcondition, use the function itself, as shown in the example.</p>
<p>By default, a function is ghost, and cannot be called from non-ghost code. To make it non-ghost, replace the keyword function with the two keywords function method.  A function that returns a boolean can be declared with the keyword predicate (and then eliding the colon and return type).</p>
<p>By default, a function in a class has an implicit receiver parameter, this. This parameter can be removed by preceding the function declaration with the keyword static. A static function F in a class C can be invoked by F.M(...). This can give a convenient way to declare a number of helper functions in a separate class.</p>
<h2>Classes</h2>
<p>A class is defined as follows:</p>
<pre>class C {
// member declarations go here
}
</pre>
<p>where the members of the class (fields, methods, and functions) are defined (as described above) inside the curly braces.</p>
<h2>Datatypes</h2>
<p>An inductive datatype is a type whose values are created using a fixed set of constructors. A datatype Tree with constructors Leaf and Node is declared as follows:</p>
<pre>datatype Tree = Leaf | Node(Tree, int, Tree)</pre>
<p>The constructors are separated by vertical bars. Parameter-less constructors need not use parentheses, as is shown here for Leaf.</p>
<p>For each constructor Ct, the datatype implicitly declares a boolean member Ct?, which returns true for those values that have been constructed using Ct. For example, after the code snippet:</p>
<pre>var t0 := Leaf; var t1 := Node(t0, 5, t0);</pre>
<p>the expression <code>t1.Node?</code> evaluates to true and <code>t0.Node?</code> evaluates to false. 
Two datatype values are equal if they have been created using the same constructor and the same parameters to that constructor. 
Therefore, for parameter-less constructors like Leaf, <code>t.Leaf?</code> gives the same result as <code>t == Leaf</code>.</p>
<p>A constructor can optionally declare a destructor for any of its parameters, which is done by introducing a name for the parameter. For example, if Tree were declared as:</p>
<pre>datatype Tree = Leaf | Node(left: Tree, data: int, right: Tree)</pre>
<p>then <code>t1.data == 5</code> and <code>t1.left == t0</code> hold after the code snippet above.</p>
<h2>Generics</h2>
<p>Dafny supports type parameters.  That is, any class, inductive datatype, method, and function can have type parameters. These are declared in angle brackets after the name of what is being declared. For example:</p>
<pre>
class MyMultiset<t> {
  /*...*/ 
}

datatype Tree</t><t> = Leaf | Node(Tree</t><t>, T, Tree</t><t>)

method Find</t><t>(key: T, collection: Tree</t><t>) { 
  /*...*/ 
}

function IfThenElse</t><t>(b: bool, x: T, y: T): T { 
  /*...*/ 
}</pre>
<h2>Statements</h2>
<p>Here are examples of the most common statements in Dafny.</p>
<pre>
  var LocalVariables := ExprList;

  Lvalues := ExprList;

  assert BoolExpr;print ExprList;

  if BoolExpr0 {
    Stmts0
  } else if BoolExpr1 {
    Stmts1
  } else {
    Stmts2
  }

  while BoolExpr 
    invariant Inv
    modifies Frame
    decreases Rank
  {
    Stmts
  }

  match Expr {
    case Empty => Stmts0
    case Node(l, d, r) => Stmts1
  }

  break;

  return;
</pre>
<p>The var statement introduces local variables (which are not allowed to shadow other variables declared inside the same set of most tightly enclosing curly braces). Each variable can optionally be followed by :T for any type T, which explicitly gives the preceding variable the type T (rather than being inferred). The ExprList with initial values is optional. To declare the variables as ghost variables, precede the declaration with the keyword ghost.</p>
<p>The assignment statement assigns each right-hand side in ExprList to the corresponding left-hand side in Lvalues. These assignments are performed in parallel (more to the point, all necessary reads occur before the writes), so the left-hand sides must denote distinct L-values. Each right-hand side can be an expression or an object creation of one of the following forms:</p>
<pre>
  new Tnew T.Init(ExprList)
  new T(ExprList)
  new T[SizeExpr]
  new T[SizeExpr0, SizeExpr1]
</pre>
<p>The first form allocates an object of type T. 
The second form additionally invokes an initialization method or constructor on the newly allocated object.
The third form shows how the syntax differs from the second form when the constructor called is anonymous.
The other forms show examples of array allocations, in particular a one- and a two-dimensional array of T values, respectively.</p>
<p>The entire right-hand side of an assignment can also be a method call, in which case the left-hand sides are the actual out-parameters (omitting the := if there are no out-parameters).</p>
<p>The assert statement claims that the given expression evaluates to true (which is checked by the verifier).</p>
<p>The print statement outputs to standard output the values of the given print expressions. Characters in strings can be escaped; for example, of interest for the print statement is that n denotes a newline character inside a string.</p>
<p>The if statement is the usual one. The example shows stringing together alternatives using else if. The else branch is optional, as usual.</p>
<p>The while statement is the usual loop, where the invariant declaration gives a loop invariant, the modifies clause restricts the modification frame of the loop, and the decreases clause introduces a variant function for the loop. By default, the loop invariant is true, the modification frame is the same as in the enclosing context (usually the modifies clause of the enclosing method), and the variant function is guessed from the loop guard.</p>
<p>The match statement evaluates the source Expr, an expression whose type is an inductive datatype, and then executes the case corresponding to which constructor was used to create the source datatype value, binding the constructor parameters to the given names.
If they are not needed to mark the end of the match statement, then the curly braces that surround the cases can be elided.</p>
<p>The break statement can be used to exit loops, and the return statement can be used to exit a method.</p>
<h2>Expressions</h2>
<p>The expressions in Dafny are quite similar to those in Java-like languages. Here are some noteworthy differences.</p>
<p>In addition to the short-circuiting boolean operators && (and) and || (or), Dafny has a short-circuiting implication operator ==> and an if-and-only-if operator <==>. As suggested by their widths, <==> has lower binding power than ==>, which in turn has lower binding power than && and ||.</p>
<p>Dafny comparison expressions can be chaining, which means that comparisons "in the same direction" can be strung together. For example,</p>
<pre>0 <= i < j <= a.Length == N</pre>
<p>has the same meaning as:</p>
<pre>0 <= i && i < j && j <= a.Length && a.Length == N</pre>
<p>Note that boolean equality can be expressed using both == and <==>. There are two differences between these. First, == has a higher binding power than <==>. Second, == is <em>chaining</em> while <==> is <em>associative</em>. That is, a == b == c is the same as a == b && b == c, whereas a <==> b <==> c is the same as a <==> (b <==> c), which is also the same as (a <==> b) <==> c.</p>
<p>Operations on integers are the usual ones, except that / (integer division) and % (integer modulo) follow the Euclidean definition, which means that % always results in a non-negative number. (Hence, when the first argument to / or % is negative, the result is different than what you get in C, Java, or C#, see <a href="http://en.wikipedia.org/wiki/Modulo_operation" target="_self">http://en.wikipedia.org/wiki/Modulo_operation</a>.)</p>

<p>Dafny expressions include universal and existential quantifiers, which have the form:</p>
<pre>forall x :: Expr</pre>
<p>and likewise for exists, where x is a bound variable (which can be declared with an explicit type, as in x: T) and Expr is a boolean expression.</p>
<p>Operations on sets include + (union), * (intersection), and &#8211; (set difference), as well as the set comparison operators < (proper subset), <= (subset), their duals > and >=, and !! (disjointness). 
The expression <code>x in S</code> says that x is a member of set S, and <code>x !in S</code> is a convenient way of writing <code>!(x in S)</code>. 
To make a set from some elements, enclose them in curly braces. 
For example, <code>{x,y}</code> is the set consisting of x and y (which is a singleton set if <code>x == y</code>), <code>{x}</code> is the singleton set containing x, and <code>{}</code> is the empty set.</p>

<p>Operations on sequences include + (concatenation) and the comparison operators < (proper prefix) and <= (prefix). 
Membership can be checked like for sets: <code>x in S</code> and <code>x !in S</code>. 
The length of a sequence S is denoted <code>|S|</code>, and the elements of such a sequence have indices from 0 to less than <code>|S|</code>. 
The expression <code>S[j]</code> denotes the element at index j of sequence S. 
The expression <code>S[m..n]</code>, where 0 <= m <= n <= |S|, returns a sequence whose elements are the n-m elements of S starting at index m (that is, from S&#091;m&#093;, S&#091;m+1&#093;, ... up to but not including S&#091;n&#093;). 
The expression S&#091;m..&#093; (often called "drop m") is the same as S&#091;m..|S|&#093;, that is, it returns the sequence whose elements are all but the first m elements of S. 
The expression S&#091;..n&#093; (often called "take n") is the same as S&#091;0..n&#093;, that is, it returns the sequence that consists of the first n elements of S. 
If j is a valid index into sequence S, then the expression S&#091;j := x&#093; is the sequence that is like S except that it has x at index j. Finally, to make a sequence from some elements, enclose them in square brackets. For example, &#091;x,y&#093; is the sequence consisting of the two elements x and y such that &#091;x,y&#093;&#091;0&#093; == x and &#091;x,y&#093;&#091;1&#093; == y, &#091;x&#093; is the singleton sequence whose only element is x, and &#091;&#093; is the empty sequence.</p>

<p>The if-then-else expression has the form:</p>
<pre>if BoolExpr then Expr0 else Else1</pre>
<p>where Expr0 and Expr1 are any expressions of the same type. 
Unlike the if statement, the if-then-else expression uses the then keyword, and must include an explicit else branch.</p>

<p>The match expression is analogous to the match statement and has the form:</p>
<pre>match Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }</pre>
<p>The curly braces can be used to mark the end of the match expression, but most commonly this is not needed and the curly braces can then be elided.</p>
</body>
</html>
